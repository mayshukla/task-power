# Task class
from datetime import date, timedelta
from pathlib import Path

from datetools import is_in_range

class Task:

    def __init__(self, task_name, units_name, units_count, work_periods):
        # task_name and units_name are strings
        # units_count is an integer
        # work_periods is a nested list of date objects [[start1, end1], [start2, end2], ... ]

        self.task_name = task_name
        self.units_name = units_name
        self.units_count = units_count
        self.work_periods = work_periods

    def get_duration(self):
        # returns total number of work days including end days
        # accounts for non-continuous work periods
        total_workdays = 0;
        for period in self.work_periods:
            # IMPORTANT: add one to include end days
            workdays_in_period = (period[1] - period[0]).days + 1
            total_workdays = total_workdays + workdays_in_period

        return total_workdays

    def get_required_rate(self):
        # returns a number respresenting units per day
        return self.units_count / self.get_duration()

    def is_active(self, date_to_check):
        # returns true if date_to_check is in any of the work periods for the given task
        # date_to_check should be date object

        output = False

        for work_period in self.work_periods:
            if is_in_range(date_to_check, work_period[0], work_period[1]):
                output = True

        return output

    def generate_text(self):
        # Returns a string containing all attributes of an instance
        # in a human-readable format.
        # This string can be used to save to a file

        string_out = 'Task name: {}\n'.format(self.task_name) \
                   + 'Units name: {}\n'.format(self.units_name) \
                   + 'Number of units: {}\n'.format(self.units_count)

        string_out = string_out + 'Work periods: '
        
        for i in range(0, len(self.work_periods)):
            string_out = string_out + '{}/{}/{}'.format(self.work_periods[i][0].year, \
                                                        self.work_periods[i][0].month, \
                                                        self.work_periods[i][0].day)
            string_out = string_out + '-'
            
            string_out = string_out + '{}/{}/{}'.format(self.work_periods[i][1].year, \
                                                        self.work_periods[i][1].month, \
                                                        self.work_periods[i][1].day)
            if i != (len(self.work_periods)-1):
                string_out = string_out + ', '
        
        string_out = string_out + '\n' # newline at end of file

        return string_out

    def save_to_file(self, taskfiles_path):
        # Takes string generated by generate text and writes to a file called <task_name>.task
        # If no file called <task_name>.task exists, create new one.
        # Otherwise, overwrite <task_name>.task
        # taskfiles_path should be a path object returned by init_taskfiles_directory()

        text_to_write = self.generate_text()
        
        # create path object that points to taskfiles/<task_name>.task
        file_path = taskfiles_path.joinpath('{}.task'.format(self.task_name))

        file_path.write_text(text_to_write)

        #try:
        #    with open(file_name, 'x') as f:
        #        f.write(text_to_write)
        #        print('New file created.')
        #except FileExistsError:
        #    with open(file_name, 'w') as f:
        #        f.write(text_to_write)
        #        print('Existing file overwritten.')
